module DualClockFIFO #(
    parameter DEPTH=8, ADDR_W=3
)(
    input logic wr_clk, wr_rst_n, wr_en,
    input logic [7:0] din,
    input logic rd_clk, rd_rst_n, rd_en,
    output logic [7:0] dout,
    output logic empty, full
);

logic [7:0] mem [DEPTH-1:0];

logic [ADDR_W:0] wr_ptr_bin, wr_ptr_gray, wr_ptr_gray_rdclk;
logic [ADDR_W:0] rd_ptr_bin, rd_ptr_gray, rd_ptr_gray_wrclk;

// write side
always_ff @(posedge wr_clk or negedge wr_rst_n) begin
    if (!wr_rst_n)
        wr_ptr_bin <= 0;
    else if (wr_en && !full) begin
        mem[wr_ptr_bin[ADDR_W-1:0]] <= din;
        wr_ptr_bin <= wr_ptr_bin + 1;
    end
end

assign wr_ptr_gray = wr_ptr_bin ^ (wr_ptr_bin >> 1);

// read side
always_ff @(posedge rd_clk or negedge rd_rst_n) begin
    if (!rd_rst_n)
        rd_ptr_bin <= 0;
    else if (rd_en && !empty)
        rd_ptr_bin <= rd_ptr_bin + 1;
end

assign rd_ptr_gray = rd_ptr_bin ^ (rd_ptr_bin >> 1);

// dout
assign dout = mem[rd_ptr_bin[ADDR_W-1:0]];

// full/empty: simplified, in real design synchronize pointers across clocks
assign full  = (wr_ptr_bin[ADDR_W-1:0]+1 == rd_ptr_bin[ADDR_W-1:0]);
assign empty = (wr_ptr_bin == rd_ptr_bin);

endmodule
